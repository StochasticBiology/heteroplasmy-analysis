# them in the resultMeans dataframe that hold the overall output of the comparisons
resultMeans[nrow(resultMeans) + 1,] = c(mean(result[,1]),mean(result[,2]),
mean(result[,3]),mean(result[,4]),
mean(result[,5]),mean(result[,6]),
mean(result[,7]),mean(result[,8]),
mean(result[,9]),mean(result[,10]))
}
row.names(resultMeans) <- ns
cl <- c("red","forestgreen","blue","gold","brown")#rainbow(4)
# cl <- rainbow(5)
names(resultMeans)[1] <- "W1 normal appr"
names(resultMeans)[2] <- "Wonnapinij et al."
names(resultMeans)[3] <- "corBoots"
names(resultMeans)[4]<-"corBoots with g(x)"
#plot the results
for (i in 1:4){
plot(y=resultMeans[,i],x=ns,ylab="Var(h)",xlab="#instance",
col = cl[i],type = "p",main="h from HB oocyte data",cex =1.2,
# col = cl[i],type = "p",main=TeX(r'(h from HB oocyte data $\mu$)'),cex =1.2,
ylim = c(0,max(resultMeans[,1:4])*2))
for (k in 1:length(ns)) {
arrows(x0=ns[k],x1=ns[k], y0=resultMeans[k,i]-resultMeans[k,i+5], y1=resultMeans[k,i]+resultMeans[k,i+5],
col = cl[i],code=3, angle=90, length=0.1)
}
par(new=TRUE)
}
legend("topright", legend=colnames(resultMeans[,1:4]),
col=cl, lty=1:2, cex=0.8)#box.lty=0
# abline(h=sqrt(0.3), col="black")
# abline(h=(exp(0.25)-1)*exp(0.25), col="black")
#
#
# fitfn <- function(theta, xvals, data) {
#   difference = 0
#   for(i in 1:length(xvals)) {
#     x = xvals[i]
#     predicted = theta[1] / (1 + theta[2]*exp(theta[3] * x + theta[4]))
#     # predicted = theta[1] + theta[2]/ (1 + exp(theta[3] * (x - theta[4])))
#     # predicted = theta[1]*exp(-theta[2] * exp(theta[3]*x))
#     # predicted= theta[2]+(theta[3]-theta[2])/(1+exp(theta[1]*(log(x)-log(theta[4]))))
#
#     difference = difference + (predicted-data[i])**2
#   }
#
#   return(difference)
# }
#
# data = resultMeans
# x=ns
#
# # x=c(seq(2, 7, by=1),seq(8, 26, by=2))#,seq(35, 70, by=5),seq(80, 100, by=10))
#
# discrepancy = data$SECorBoots/data$SEW2
# fitted.model = optim(c(1, 1, 1, 1), fitfn, xvals = x, data =
#                        discrepancy)
# fitted.pars = fitted.model$par
# y = fitted.pars[1] / (1 + fitted.pars[2]*exp(fitted.pars[3]*x +fitted.pars[4]))
# # y = fitted.pars[1] + fitted.pars[2]/ (1 + exp(fitted.pars[3] * (x - fitted.pars[4])))
# # y = fitted.pars[1]*exp(-fitted.pars[2] * exp(fitted.pars[3]*x))
# # y= fitted.pars[2]+(fitted.pars[3]-fitted.pars[2])/(1+exp(fitted.pars[1]*(log(x)-log(fitted.pars[4]))))
#
#
# plot(discrepancy)
# lines(y)
#
#
# # y = fm[["coefficients"]][1]*exp(-fm[["coefficients"]][2] * exp(fm[["coefficients"]][3]*x))
#
# y=fm[["coefficients"]][2]+(fm[["coefficients"]][3]-fm[["coefficients"]][2])/(1+exp(fm[["coefficients"]][1]*(log(x)-log(fm[["coefficients"]][4]))))
#
# discrepancy=cbind(discrepancy,x)
# discrepancy=as.data.frame(discrepancy)
# fm <- drm(discrepancy ~ x, data = discrepancy, fct = LL.4())# LL2.5 LL2.3u G.3 LL.4
# plot(fm)
plotStdErrVar(X.1)
build_manual(pkg = "heteroplasmy")
setwd("C:/Users/kgi062/Desktop/mydata/code/heteroplasmy/heteroplasmyVar")
build_manual(pkg = "heteroplasmy")
build_manual(pkg = "./heteroplasmy")
setwd("./heteroplasmy")
build_manual(pkg = "./heteroplasmy")
build_manual(pkg = "heteroplasmy")
setwd("C:/Users/kgi062/Desktop/mydata/code/heteroplasmy/heteroplasmyVar")
setwd("C:/Users/kgi062/Desktop/mydata/code/heteroplasmy/heteroplasmyVar/heteroplasmy")
build_manual(pkg = "heteroplasmy")
setwd("./heteroplasmy")
setwd("C:/Users/kgi062/Desktop/mydata/code/heteroplasmy/heteroplasmyVar")
build_manual(pkg = "heteroplasmy")
library(latex2exp)#latex
build_manual(pkg = "heteroplasmy",path=NULL)
pack <- "heteroplasmy"
path <- find.package(pack)
system(paste(shQuote(file.path(R.home("bin"), "R")),
"CMD", "Rd2pdf", shQuote(path)))
install_github('heteroplasmy','kostasgian21')
devtools:install_github('heteroplasmy','kostasgian21')
library
(devtools)
library(devtools)
install_github('heteroplasmy','kostasgian21')
devtools:install_github('heteroplasmy','kostasgian21')
devtools:install_github("heteroplasmy","kostasgian21")
install_github("heteroplasmy","kostasgian21")
install_github("kostasgian21/heteroplasmy","kostasgian21")
install_github("kostasgian21/heteroplasmy")
?use_data
?analyticVar
setwd("./heteroplasmy")
document()
?analyticVar
X.1
X.1M=as.matrix(X.1M)
X.1M=as.matrix(X.1)
analyticVar(X.1)
analyticVar(X.1M)
setwd("./heteroplasmy")
document()
?analyticVar
devtools::build(heteroplasmy)
devtools::build()
setwd("./heteroplasmy")
document()
setwd("./heteroplasmy")
document()
sd(bootVars)*((n - opti)/n)/(coeC+(coeD-coeC)/(1+exp(coeB*(log(n)-log(coeE)))))
ee= sd(bootVars)*((n - opti)/n)/(coeC+(coeD-coeC)/(1+exp(coeB*(log(n)-log(coeE)))))
citation('drc')
ee= sd(bootVars)*((n - opti)/n)/(coeC+(coeD-coeC)/(1+exp(coeB*(log(n)-log(coeE)))))
ee
ww= sd(bootVars)*((n - opti)*(1+exp(coeB*(log(n)-log(coeE))))/n*(coeC+(coeD-coeC))
ww
ww= sd(bootVars)*((n - opti)*(1+exp(coeB*(log(n)-log(coeE))))/n*(coeC+(coeD-coeC))
)
ww
ee
ww= sd(bootVars)*(((n - opti)*(1+exp(coeB*(log(n)-log(coeE)))))/(n*(coeC+(coeD-coeC))))
ww
ee
# library("devtools")
# devtools::install_github("klutometis/roxygen")
# library(roxygen2)
# setwd("C:/Users/kgi062/Desktop/mydata/code/heteroplasmy/heteroplasmyVar")
# create("heteroplasmy")
library(drc)
# library(latex2exp)#latex
# library(DataEditR)#edit data frames
setwd("C:/Users/kgi062/Desktop/mydata/code/heteroplasmy")
set.seed(179)
# setwd("./heteroplasmy")
# document()
# devtools::build()#to make a bundle of the package
readHeteroplasmyData <- function(nameD="HB") {
# return a new vector containing the mouse data
if (nameD=="HB") {
mouseData <- read.table("HB oocyte data.txt", sep="\t",header=T)
mouseData=mouseData[,-c(1,2)]
mouseData=mouseData[-c(1:11),]
mouseData=mouseData[which(mouseData[,]!=""),]
mouseData[, ] <- sapply(mouseData[, ], as.numeric)
}else if(nameD=="LE"){
mouseData <- read.table("LE oocyte data.txt", sep="\t",header=T)
mouseData=mouseData[,-1]
mouseData=mouseData[-c(1:10),]
mouseData=mouseData[which(mouseData[,]!=""),]
mouseData[, ] <- sapply(mouseData[, ], as.numeric)
}else{
mouseData=NULL
print("wrong input, please use HB or LE")
}
return(mouseData)
}
##############################################
##############################################
##############################################
analyticVar <- function(data,normal=FALSE) {
n=length(which(!is.na(data)))
X.1 = data
#X.1=X.1/100
h0=mean(X.1)
sampleVar=var(X.1)
# SEW1 and SEW are the standard error of the variance from
# Wonnapinij et al. SEW1 is the normal approximation and SEW2
# is the generic type
mu2=(1/n)*sum((X.1-h0)^2)
mu4=(1/n)*sum((X.1-h0)^4)
D4=((n-1)/(n^3))*((n^2-3*n+3)*mu4+3*(2*n-3)*mu2^2)
SEW1=sampleVar*sqrt(2/(n-1))# standard error,normal approximation
SEW2=sqrt((1/n)*(D4-sampleVar^2*((n-3)/(n-1))))# standard error, not normal structure
if (normal==TRUE) {
message("Normal approximation of the standard error of the variance")
return(SEW1)
}else{
return(SEW2)
}
}
##############################################
##############################################
##############################################
bootstrapVar <- function(data,nrep=1000,biased=FALSE,corrected=FALSE,sigmaOpt=FALSE) {
n=length(which(!is.na(data)))
X.1 = data
#X.1=X.1/100
h0=mean(X.1)
opti = 2.61
coeB=-4.1434
coeC=-0.7387
coeD=1.0125
coeE=2.8390
X.1_boot=as.data.frame(X.1)
boots = vector()
bootVars=vector()
bootVarsBiased=vector()
for (i in 1:nrep) {
repeat {
boot= sample(1:nrow(X.1_boot), nrow(X.1_boot), replace=TRUE)
boots=X.1_boot[boot,1]
if (!is.na(var(boots,na.rm = TRUE))) {
break
}
}
#append the corrected variance of the i-th bootstrap sample
bootVars= c(bootVars,var(boots,na.rm = TRUE)*(n/(n - 1)))
bootVarsBiased= c(bootVarsBiased,var(boots,na.rm = TRUE))
}
# standard error of the bootstrap samples
SEB=sd(bootVars)
heteropVar=SEB
if (biased==TRUE) {
warning("Cautious, biased calculation always underestimates the variance!")
SEB=sd(bootVarsBiased)
heteropVar=SEB
}
if (corrected==TRUE) {
message("Correceted by a constant factor")
heteropVar=SEB*((n - opti)/n)
}
if (sigmaOpt==TRUE) {
message("Correceted by a fitted sigmoid function, ie a four-parameter log-logistic function")
heteropVar=SEB*((n - opti)/n)/(coeC+(coeD-coeC)/(1+exp(coeB*(log(n)-log(coeE)))))
}
return(heteropVar)
}
##############################################
##############################################
##############################################
jackVar <- function(data) {
n=length(which(!is.na(data)))
X.1 = data
#X.1=X.1/100
h0=mean(X.1)
if (n<2) {
stop("Input data should have size >1")
return()
}
# jackknife resampling -- pseudo reports the vars of each subsample
# and pseudoSE is for the calculation of its standard error
pseudo <- numeric(length(X.1))
for (ww in 1:length(X.1)) {
pseudo[ww] <- var(X.1[-ww])
}
pseudoSE <- sqrt(((n - 1)/n) * sum((pseudo - mean(pseudo))^2))
return(pseudoSE)
}
##############################################
##############################################
##############################################
plotStdErrVar <- function(data,functions=c("normalApr","analytic","bootstrap","correctedBoot","jackknife"),...) {
functions <- list(...)
if (length(functions)==0) {
functions=c("normalApr","analytic","bootstrap","correctedBoot","jackknife")
}
sampleVar=var(data)
resultMeans= data.frame(W1=numeric(),
W2=numeric(),
Boots=numeric(),
CorBoots=numeric(),
Jack=numeric(),
SEW1=numeric(),
SEW2=numeric(),
SEBoots=numeric(),
SECorBoots=numeric(),
SEJack=numeric())
if ("analytic" %in% functions) {
anvar=analyticVar(data)
}
if ("normalApr" %in% functions) {
anvarN=analyticVar(data,normal = TRUE)
}
if ("bootstrap" %in% functions) {
bootVar=bootstrapVar(data)
}
if ("correctedBoot" %in% functions) {
bootVarOpt=bootstrapVar(data,sigmaOpt = TRUE)
}
if ("jackknife" %in% functions) {
jackVar=jackVar(data)
}
resultMeans[1,] = c(sampleVar,sampleVar,sampleVar,sampleVar,
sampleVar,anvarN,anvar,bootVar,
bootVarOpt,jackVar)
ns=c(1)
# row.names(resultMeans) <- ns
cl <- c("red","forestgreen","blue","gold","brown")#rainbow(4)
# cl <- rainbow(5)
names(resultMeans)[1] <- "W1 normal appr"
names(resultMeans)[2] <- "Wonnapinij et al."
names(resultMeans)[3] <- "corBoots"
names(resultMeans)[4]<-"corBoots with g(x)"
#plot the results
for (i in 1:5){
plot(y=resultMeans[,i],x=ns,ylab="Var(h)",xlab="#instance",
col = cl[i],type = "p",main="h from HB oocyte data",cex =1.2,
# col = cl[i],type = "p",main=TeX(r'(h from HB oocyte data $\mu$)'),cex =1.2,
ylim = c(0,max(resultMeans[,1:5])*2))
for (k in 1:length(ns)) {
arrows(x0=ns[k],x1=ns[k], y0=resultMeans[k,i]-resultMeans[k,i+5], y1=resultMeans[k,i]+resultMeans[k,i+5],
col = cl[i],code=3, angle=90, length=0.1)
}
par(new=TRUE)
}
legend("topright", legend=colnames(resultMeans[,1:5]),
col=cl, lty=1:2, cex=0.8)#box.lty=0
}
##############################################
##############################################
##############################################
# mouseData <- read.table("HB oocyte data.txt", sep="\t",header=T)
# #HB oocyte data    HB pup data    LE oocyte data    LE pup data   Oocyte summary
# # mouseData=mouseData[,-1]
# # mouseData=mouseData[-c(1:10),]
#
#
# mouseData=mouseData[,-c(1,2)]
# mouseData=mouseData[-c(1:11),]
# mouseData=mouseData[which(mouseData[,]!=""),]
# mouseData[, ] <- sapply(mouseData[, ], as.numeric)
mouseData=readHeteroplasmyData("HB")
opti = 2.61
coeB=-4.1434
coeC=-0.7387
coeD=1.0125
coeE=2.8390
# opti = exp(1)#2.61
# coeB=-3-pi
# coeC=-exp(1)+2
# coeD=1
# coeE=exp(1)
# #size of n
# # ns=c(seq(3, 7, by=1),seq(8, 22, by=2))#,seq(35, 70, by=5),seq(80, 100, by=10))
# ns=c(seq(2, 7, by=1),seq(8, 26, by=2))#,seq(35, 70, by=5),seq(80, 100, by=10))
# ns=seq(2, 25, by=1)
ns=seq(1, length(mouseData), by=1)
ratio=vector()
ratioCor=vector()
nr=vector()
resultMeans= data.frame(W1=numeric(),
W2=numeric(),
Boots=numeric(),
CorBoots=numeric(),
Jack=numeric(),
SEW1=numeric(),
SEW2=numeric(),
SEBoots=numeric(),
SECorBoots=numeric(),
SEJack=numeric())
#loop throughout different values of n
for (z in 1:length(mouseData)) {
n=ns[z]
n=length(which(!is.na(mouseData[,z])))
result= data.frame(W1=numeric(),
W2=numeric(),
Boots=numeric(),
CorBoots=numeric(),
Jack=numeric(),
SEW1=numeric(),
SEW2=numeric(),
SEBoots=numeric(),
SECorBoots=numeric(),
SEJack=numeric())
#100 repetitions for each value of n to obtain average's
for (j in 1:1) {
#sample data/heteroplasmies from a known distribution
X.1 = mouseData[which(!is.na(mouseData[,z])),z]
X.1=X.1/100
# X.1 = rbeta(n,5,1)
# X.1 = rnorm(n,0.5,0.1)
# X.1=rlnorm(n, meanlog = 0, sdlog = 0.25)
n=length(X.1)
#mean and variance of the sample heteroplasmy
h0=mean(X.1)
sampleVar=var(X.1)
# SEW1 and SEW are the standard error of the variance from
# Wonnapinij et al. SEW1 is the normal approximation and SEW2
# is the generic type
mu2=(1/n)*sum((X.1-h0)^2)
mu4=(1/n)*sum((X.1-h0)^4)
D4=((n-1)/(n^3))*((n^2-3*n+3)*mu4+3*(2*n-3)*mu2^2)
SEW1=sampleVar*sqrt(2/(n-1))# standard error,normal approximation
SEW2=sqrt((1/n)*(D4-sampleVar^2*((n-3)/(n-1))))# standard error, not normal structure
# bootstrap calculation of the sample variance and standard error of it
X.1_boot=as.data.frame(X.1)
boots = vector()
bootVars=vector()
nrep=800 #number of bootstrap trials
for (i in 1:nrep) {
repeat {
boot= sample(1:nrow(X.1_boot), nrow(X.1_boot), replace=TRUE)
boots=X.1_boot[boot,1]
if (!is.na(var(boots,na.rm = TRUE))) {
break
}
}
#append the corrected variance of the i-th bootstrap sample
bootVars= c(bootVars,var(boots,na.rm = TRUE)*(n/(n - 1)))
}
# standard error of the bootstrap samples
SEB=sd(bootVars)
# jackknife resampling -- pseudo reports the vars of each subsample
# and pseudoSE is for the calculation of its standard error
pseudo <- numeric(length(X.1))
for (ww in 1:length(X.1)) {
pseudo[ww] <- var(X.1[-ww])
}
pseudoSE <- sqrt(((n - 1)/n) * sum((pseudo - mean(pseudo))^2))
# result is the dataframe that holds the result for the i-th repetition (same n)
result[nrow(result) + 1,] = c(sampleVar,sampleVar,mean(bootVars),mean(bootVars),
mean(pseudo),SEW1,SEW2,sd(bootVars)*((n - 2.61)/n),
sd(bootVars)*(((n - opti)*(1+exp(coeB*(log(n)-log(coeE)))))/(n*(coeC+(coeD-coeC)))),#(fm[["coefficients"]][2]+(fm[["coefficients"]][3]-fm[["coefficients"]][2])/(1+exp(fm[["coefficients"]][1]*(log(n)-log(fm[["coefficients"]][4]))))),#+sd(bootVars)*(fitted.pars[1]/(1 + fitted.pars[2]*exp(fitted.pars[3]*n +fitted.pars[4]))),
pseudoSE)
}
# take the means for the 100 repetitions for the same n and report
# them in the resultMeans dataframe that hold the overall output of the comparisons
resultMeans[nrow(resultMeans) + 1,] = c(mean(result[,1]),mean(result[,2]),
mean(result[,3]),mean(result[,4]),
mean(result[,5]),mean(result[,6]),
mean(result[,7]),mean(result[,8]),
mean(result[,9]),mean(result[,10]))
}
row.names(resultMeans) <- ns
cl <- c("red","forestgreen","blue","gold","brown")#rainbow(4)
# cl <- rainbow(5)
names(resultMeans)[1] <- "W1 normal appr"
names(resultMeans)[2] <- "Wonnapinij et al."
names(resultMeans)[3] <- "corBoots"
names(resultMeans)[4]<-"corBoots with g(x)"
#plot the results
for (i in 1:4){
plot(y=resultMeans[,i],x=ns,ylab="Var(h)",xlab="#instance",
col = cl[i],type = "p",main="h from HB oocyte data",cex =1.2,
# col = cl[i],type = "p",main=TeX(r'(h from HB oocyte data $\mu$)'),cex =1.2,
ylim = c(0,max(resultMeans[,1:4])*2))
for (k in 1:length(ns)) {
arrows(x0=ns[k],x1=ns[k], y0=resultMeans[k,i]-resultMeans[k,i+5], y1=resultMeans[k,i]+resultMeans[k,i+5],
col = cl[i],code=3, angle=90, length=0.1)
}
par(new=TRUE)
}
legend("topright", legend=colnames(resultMeans[,1:4]),
col=cl, lty=1:2, cex=0.8)#box.lty=0
# abline(h=sqrt(0.3), col="black")
# abline(h=(exp(0.25)-1)*exp(0.25), col="black")
#
#
# fitfn <- function(theta, xvals, data) {
#   difference = 0
#   for(i in 1:length(xvals)) {
#     x = xvals[i]
#     predicted = theta[1] / (1 + theta[2]*exp(theta[3] * x + theta[4]))
#     # predicted = theta[1] + theta[2]/ (1 + exp(theta[3] * (x - theta[4])))
#     # predicted = theta[1]*exp(-theta[2] * exp(theta[3]*x))
#     # predicted= theta[2]+(theta[3]-theta[2])/(1+exp(theta[1]*(log(x)-log(theta[4]))))
#
#     difference = difference + (predicted-data[i])**2
#   }
#
#   return(difference)
# }
#
# data = resultMeans
# x=ns
#
# # x=c(seq(2, 7, by=1),seq(8, 26, by=2))#,seq(35, 70, by=5),seq(80, 100, by=10))
#
# discrepancy = data$SECorBoots/data$SEW2
# fitted.model = optim(c(1, 1, 1, 1), fitfn, xvals = x, data =
#                        discrepancy)
# fitted.pars = fitted.model$par
# y = fitted.pars[1] / (1 + fitted.pars[2]*exp(fitted.pars[3]*x +fitted.pars[4]))
# # y = fitted.pars[1] + fitted.pars[2]/ (1 + exp(fitted.pars[3] * (x - fitted.pars[4])))
# # y = fitted.pars[1]*exp(-fitted.pars[2] * exp(fitted.pars[3]*x))
# # y= fitted.pars[2]+(fitted.pars[3]-fitted.pars[2])/(1+exp(fitted.pars[1]*(log(x)-log(fitted.pars[4]))))
#
#
# plot(discrepancy)
# lines(y)
#
#
# # y = fm[["coefficients"]][1]*exp(-fm[["coefficients"]][2] * exp(fm[["coefficients"]][3]*x))
#
# y=fm[["coefficients"]][2]+(fm[["coefficients"]][3]-fm[["coefficients"]][2])/(1+exp(fm[["coefficients"]][1]*(log(x)-log(fm[["coefficients"]][4]))))
#
# discrepancy=cbind(discrepancy,x)
# discrepancy=as.data.frame(discrepancy)
# fm <- drm(discrepancy ~ x, data = discrepancy, fct = LL.4())# LL2.5 LL2.3u G.3 LL.4
# plot(fm)
setwd("./heteroplasmy")
document()
setwd("C:/Users/kgi062/Desktop/mydata/code/heteroplasmy/heteroplasmyVar")
setwd("./heteroplasmy")
document()
setwd("./heteroplasmy")
document()
